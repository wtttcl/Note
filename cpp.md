# C++

### 1. 声明和定义（分配空间）

声明：告诉编译器一个变量或者函数的名字、返回类型、参数信息等，但不分配空间。

定义：在程序中为某个变量、函数等 **分配内存空间**，以便使用。

**变量的声明和定义**

- 定义性声明：在声明时就实现定义，比如，`int a`。
- 引用性声明：比如声明外部定义的变量，关键词 `extern`，告诉编译器该变量已经在别处定义过了。

**函数的声明和定义**

- 声明：告诉编译器这个函数在别处已定义。
- 定义：带函数体。

### 2. c 和 c++ 的区别，c++ 的三大特性

c：面向过程。分析解决问题的步骤，然后代码实现步骤

- 性能更好，因为类需要实例化，开销大。Linux、嵌入式等一般采用面向过程开发。

c++：面向对象。把问题分解成各个对象，描述某个事务在整个解决问题的步骤中的行为。

- 易维护、易复用、易扩展。由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活和易于维护。

#### - c++ 三大特性

- 封装。数据安全。

- 继承。代码重用，功能扩充。

- 多态。接口重用。
  - 静态多态：重载函数。
  - 动态多态 / 运行时多态：虚函数实现。

### 3. 重载、覆盖和隐藏

重载：在同一个类 / 同一个作用域中，函数名相同，参数不同。

覆盖：派生类覆盖基类的虚函数。函数名相同，参数也相同。

隐藏：派生类隐藏基类的非虚函数。函数名相同，参数也相同。（当派生类存在一个和基类非虚函数函数名相同、参数也相同的函数时，派生类会覆盖基类的同名同参函数）

### 4. c++ 中的虚函数和纯虚函数

虚函数是实现 **多态** 的一种方式，当 **基类希望派生类重新定义某成员函数** 时，基类用关键词 `virtual` 修饰这些函数，将其声明为虚函数。

- 基类定义的虚函数在所有派生类中都是虚函数。
- 派生类中覆盖基类的虚函数时，可以不带关键词 `virtual` 。
- 关键词 `virtual` 只能出现在 **类内部的函数声明** 中，不能用于 **类外部的函数定义**。

```c++
class Animal {
public:
    // virtual 只能出现在类内部的函数声明中，不能用于类外部的函数定义
	virtual void makeSound() {
		std::cout << "Animal makes a sound" << std::endl;
	}
};
```

#### - 虚函数和非虚函数

在 C++ 中，基类必须将它的两种成员函数区分开：

- 非虚函数：基类希望直接继承给派生类而不需要改写的函数。**静态绑定**，即解析过程发生在编译而非运行时
- 虚函数：基类希望派生类进行覆盖的函数：定义为虚函数。**动态绑定**，即根据对象类型不同，调用该虚函数时可能执行基类的版本，也可能执行某个派生类的版本，因此需要在程序运行时确定。由于只有在程序运行时才知道调用哪个版本的虚函数，因此 **所有虚函数都必须有定义**，就是不使用虚函数，也必须定义它。

#### - 关键词 override

C++11 允许派生类使用 `override` 关键字显式注明哪个成员函数是改写的基类的虚函数，代码示例如下：

```c++
#include <iostream>


class Animal {
private:
	int nums;
public:
	Animal() = default;
	Animal(int nums_) : nums(nums_) {};
	virtual void printNum() {
		std::cout << "The number of animals is: " << nums << std::endl;
	}
};

class Dog :public Animal {
private:
	int nums;
public:
	Dog() = default;
	Dog(int nums_) : nums(nums_) {};
	void printNum() override {
		std::cout << "The number of dog is: " << nums << std::endl;
	}
};

int main(){
	Animal animal(100);
	animal.printNum();   // The number of animals is: 100
	Dog dog(5);
	dog.printNum();      // The number of dog is: 5
	return 0;
}
```

#### - 构造函数不可以定义为虚函数，析构函数最好定为虚函数

构造函数不可以是虚函数

- 构造函数是在创建对象时执行的，而虚函数是程序运行时执行的；也就是说在创建对象时虚函数还没确定用那个版本呢，所以构造函数不可以是虚函数。

析构函数可以是虚函数且最好写成虚函数

- 如果析构函数不是虚函数，则容易造成内存泄露。因为，若有父类指针指向子类对象存在，需要析构的是子类对象；但父类析构函数不是虚函数，则只析构了父类，造成子类对象没有及时释放，引起内存泄漏。

#### - 静态成员函数不能是虚函数（所有对象公用一个），内联函数不能是虚函数（在编译时就要确定函数体）

#### - 类的虚表

**每个包含了虚函数的类都包含一个虚表。**

- 不管多少个对象，都是用的是同一个虚表。
- 虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。虚表内的条目，即虚函数指针的赋值发生在 **编译器的编译阶段**，也就是说在代码的编译阶段，虚表就可以构造出来了。（非虚函数不会经历需表）

- 如果一个基类包含了虚函数，那么其派生类也就继承了这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。

假设类 A 包含虚函数 vfunc1，vfunc2，由于类 A 包含虚函数，故类A拥有一个虚表。

```c++
class A {

public:

    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();

private:

    int m_data1, m_data2;
};
```

类 A 的虚表：

<img src="./assets/20160528105449641.png" alt="这里写图片描述" style="zoom:50%;" />

#### - 类的虚表指针

每个对象都有一个指向虚表的指针。为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。

<img src="./assets/20160528105539173.png" alt="这里写图片描述" style="zoom:67%;" />

#### - 虚函数的动态绑定流程

例如，类A是基类，类B继承类A，类C又继承类B。

```c++
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};

class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类 A 类 B 类 C 对象模型：**（虚表应该还包含从基类中继承的虚函数）**

<img src="./assets/20160528104806455.png" alt="这里写图片描述" style="zoom: 50%;" />

基类的指针只能调用基类的方法，但是记住 **虚函数的指针是基类的，其他子类继承下来也只是继承了使用权**。

假设我们定义一个类 B 的对象。由于 `bObject` 是类 B 的一个对象，故 `bObject` 包含一个虚表指针，指向类 B 的虚表。

现在，我们声明一个类 A 的指针 p 来指向对象 `bObject`。虽然 **p 是基类的指针只能指向基类的部分**，但是虚表指针亦属于基类部分，**其值不会改变**，所以 p 可以访问到对象 `bObject` 的虚表指针，进而访问类 B 的需表。

```c++
int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1();
}
```

程序在执行 `p->vfunc1()` 时，会发现 p 是个指针，且调用的函数是虚函数，那么程序会根据虚表指针 `p->vptr` 来访问对象 `bObject` 对应的虚表，然后在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。最后，根据虚表中找到的函数指针，调用函数。所以 `p->vfunc1()` 实质会调用 `B::vfunc1()` 函数。

#### - 纯虚函数

纯虚函数：纯虚函数是**一种特殊的虚函数**，在许多情况下，在**基类中不能对虚函数给出有意义的实现**，而把它声明为纯虚函数，它的实现留给**该基类的派生类**去做。

##### 虚函数与纯虚函数的区别

- 纯虚函数是虚函数的一种，但是虚函数可以在基类中实现，纯虚函数不能在基类中实现，且必须在子类中实现。

- 包含虚函数的类可以被实例化，包含纯虚函数的类（抽象类）不能被实例化。

```c++
class Animal {
public:
	virtual void makeSound() = 0 {} 	// 纯虚函数
};
```

#### - 抽象类

含有纯虚函数的类称为抽象类。

如下面的代码中对 Animal 抽象类的实例化会编译报错。

```c++
#include <iostream>

class Animal {
	// 这里的 = 0 没有任何实际意义，只起形式上的作用，告诉编译系统"这是纯虚函数"
	virtual void makeSound() = 0{}
};

int main(){
	Animal animal();   // 报错：不能实例化抽象类
	return 0;
}
```

### 5. 静态绑定和动态绑定

绑定：将 **变量** 和 **函数名** 转换为地址的过程。

静态绑定：编译时绑定，即，在编译阶段,该语句已经被编译成 “**call 函数地址**” 类似的汇编指令。

动态绑定：直到程序运行时才能确定调用哪个函数。（指针指向函数表，查表获取调用函数的指针）

- 动态绑定的条件：①有指针或引用②向上转型（基类指针接受派生类对象）③调用虚函数

  ```c++
  A* pa = new B;
  pa->vfunc1();
  
  pa = &b;
  pa->vfunc1();
  ```

### ==5. c 和 c++ 中结构体的区别，c++ 中结构体和类的区别==

c++ 中结构体和类差不多，结构体中可以包含函数；也可以定义public、private、protected数据成员；但结构体的默认属性是 public，类的默认属性是 private。

**c++ 中结构体和类的区别**

- 

**c 和 c++ 中结构体的区别**

- C 结构体致涉及数据，不涉及算法，只是一个存储数据的结构。

- C 结构体要在定义时加上 typedef 才能设置别名，否则必须用 struct + 结构体名。C++ 结构体可以直接设置别名。

  ```cpp
  typedef struct Student{
      int sNo;
      char name[10];
  }Stu;
  int main(){
      struct Student stu;  //方式一
      Stu stu1;            //方式二
  }
  ```

- C 结构体只有 public 一种权限，而 C++ 结构体有 public、private、protect 三种权限。
- C 结构体不能在结构体中初始化成员变量，而 C++ 结构体可以。

- C 中结构体不能有成员函数，而 C++ 中可以有，甚至可以有虚函数。所以 C 中不存在构造函数、虚构函数和 this 指针。
- 
- C 结构体没有继承关系，而 C++ 结构体可以从类或者其他结构体继承而来。
- 
- C 结构体在定义时除非使用 typedef，否则之后定义变量都必须跟上 struct + 结构体名，而 C++ 结构体可以直接使用结构体名，不受限制。
- C 结构体不能有静态成员变量，而 C++ 结构体可以有。
- C 结构体的空结构体 sizeof 为 0，C++的 sizeof 为 1。

# C++ 11 新特性

### 2.1auto 和 decltype

> C++11中用auto关键字来支持自动类型推导。用decltype推导表达式类型。头文件：#include<typeinfo>

auto：让编译器在编译器就推导出变量的类型，可以通过=右边的类型推导出变量的类型。（前提是定义一个变量时对其进行初始化）

```cpp
auto a = 10; // 10是int型，可以自动推导出a是int
```

decltype：用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。（decltypde是不需要推导变量初始化的，根据的是表达式对变量的类型就可以推导。）

```text
auto varname = value;
decltype(exp) varname = value;
decltype(10.8) x;  //x 被推导成了 double
```

两者区别：

1，auto用于变量的类型推导，根据初始化表达式的类型来推导变量的类型，常用于简化代码和处理复杂类型。而decltype则用于获取表达式的类型，保留修饰符，并且可以进行表达式求值。

2，auto在初始化时进行类型推导，而decltype直接查询表达式的类型，可以用于任何表达式，包括没有初始化的变量。

3，auto在编译期间确定类型，并且无法更改。而decltype在运行时才确定表达式的类型。

4，auto适用于简单的类型推导，而decltype适用于复杂的类型推导和获取表达式的结果类型。

### 2.2范围 for

在C++11中，引入了范围for循环（Range-based for loop），它提供了一种简洁而直观的方式来遍历容器、数组、字符串和其他可迭代对象。

```text
for (auto element : container) {
    // 操作每个元素
}
```

其中，`element` 是一个变量，用于存储容器中的每个元素的值。`container` 是一个可迭代对象，例如数组、标准库容器或自定义容器。

范围for循环的工作原理是，它会自动遍历容器中的每个元素，并将当前元素的值赋给 `element` 变量，然后执行循环体中的代码块。循环体会针对容器中的每个元素执行一次。

```text
//实例：
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    for (auto number : numbers) {
        std::cout << number << " ";
    }

    return 0;
}
```

# 系统

# 网络

# 数据库

# 力扣



#### 

#### 

#### 指针和引用的区别

#### TCP/IP 四层

#### TCP 和 UDP 和 HTTP，它们之间的区别是什么？

#### 多线程间的同步方法有哪些

#### 进程和线程的区别是什么？有哪通信些方式呢

#### 编译的过程

#### 数组和链表的优缺点

#### stl 库

#### python2 和 python3 的区别

#### python 装饰器

#### 常用的 python 库

#### Numpy 合并数组

#### Mysql 事务，

#### 索引，索引的底层存储结构，B+树，然后问为什么要用B+树

#### 操作系统相关的，进程调度算法

#### Linux相关的，是否用过，常用命令

#### 面向对象编程思想的理解，三大特性

#### 

#### map和list

#### 介绍内存分区

#### 用free释放会有什么问题吗？

#### 设计模式 单例模式和工厂模式，还有观察者模式这几个比较主流的模式

#### 懒汉模式和恶汉模式线程安全问题要怎么解

#### **2.用到过哪些C++11新特性，auto和**decltype

#### c加加11的新标准，拉姆表达式的话它那个传值有几种方式，lambda表达式按值传递和按引用传递

#### Linux基础的指令

#### c加加11里面的原子变量，条件变量

#### 数据库怎么操作增删改查

#### 数据库类型

#### 预处理过程

#### git 版本管理工具上传和拉取。

#### 手写个strcpy

#### 入口函数两个参数含义

#### 引用传值和直接传值区别？

#### 静态变量常量

#### C++空类中包含什么

#### 重写的时候很多人会在这个虚构函数前面加一个那个就是这个这个关键字，这个关键字干什么用的。

#### 用过哪些数据库？

#### 怎么去连接数据库？这个连接方法在哪儿调用？

#### SQL语句怎么去执行呢

#### 数据库常用API

#### 用socket编程写一个客户端，它的基本步骤是哪些

#### 短时间的客户端很多连接请求怎么办？

#### Linux的一般的那个就是命令行

#### 环境变量是干什么用的？

#### 动态库的概念，动态库是干什么用的？

#### 这台笔记本电脑，对吧？它主要是由哪几部分组成组成的呀？

### 力扣题

#### 合并有序链表数组















1. 声明和定义的区别

   - 声明：向编译器宣告标识符（如变量、函数、类等）的存在和类型，但不分配内存或者不提供具体实现。声明告诉编译器，“这个东西在某处存在，你将在后面找到它的定义”。

     ```c++
     extern int x;
     ```

     

   - 定义告诉编译器，“这个东西在这里真正被创建了”。

     ```c++
     int x = 5;
     ```

2. 要想 **建立在整个类中都恒定的常量**，需要用 `static const`。

   在 C++ 中：

   - 静态成员变量是 **类的所有对象共有的**，**不属于任何一个类对象**。==静态成员变量被存储在栈中（？）==。
   - 静态成员变量必须在 **类外定义**，在 **类内声明**，且定义时不用添加 `static` 关键字，但要指明属于哪个类。
   - 要想 **建立在整个类中都恒定的常量**，需要用 `static const`。

   ```c++
   class Solution {
   private:
       static const int HIGH_BIT = 30;
   
   public:
       int findMaximumXOR(vector<int>& nums)
       {
           for (int k = HIGH_BIT; k >= 0; --k)
           {...}
   		...
       }
   };
   
   ```

3. ==类内成员变量，static 和 const 和 static const 区别。==





1. string.h cstring string 的区别
