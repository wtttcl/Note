https://blog.csdn.net/weixin_42246291/article/details/129318984

选一个自己觉得收获最大的项目介绍一下

3、在项目中遇到哪些困难，又是如何解决的

4、项目还有哪些可以优化的地方

毕业课题，先介绍项目的主要内容，然后目前所做出的成果，以及国内外的研究现状，项目的创新点以及缺陷

2、除了毕业课题，为什么做了另外两个项目

3、介绍内存池和web服务器项目，然后问项目实现的方法以及缺陷等等，问得很深

在做项目的时候有没有遇到什么问题？



# WebServer

**项目介绍**

- 为什么要做这样一个项目？
- 介绍下你的项目

**线程池相关**

###### **a. 手写线程池**

```c++
#ifndef THREADPOOL_H
#define THREADPOOL_H

#include <list>
#include <cstdio>
#include <exception>
#include <pthread.h>
#include "locker.h"

// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类
template<typename T>
class threadpool {
public:
    /*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/
    threadpool(int thread_number = 8, int max_requests = 10000);
    ~threadpool();
    bool append(T* request);

private:
    /*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/
    static void* worker(void* arg);
    void run();

private:
    // 线程的数量
    int m_thread_number;  
    
    // 描述线程池的数组，大小为m_thread_number    
    pthread_t * m_threads;

    // 请求队列中最多允许的、等待处理的请求的数量  
    int m_max_requests; 
    
    // 请求队列
    std::list< T* > m_workqueue;  

    // 保护请求队列的互斥锁
    locker m_queuelocker;   

    // 是否有任务需要处理
    sem m_queuestat;

    // 是否结束线程          
    bool m_stop;                    
};

template< typename T >
threadpool< T >::threadpool(int thread_number, int max_requests) : 
        m_thread_number(thread_number), m_max_requests(max_requests), 
        m_stop(false), m_threads(NULL) {

    if((thread_number <= 0) || (max_requests <= 0) ) {
        throw std::exception();
    }

    m_threads = new pthread_t[m_thread_number];
    if(!m_threads) {
        throw std::exception();
    }

    // 创建thread_number 个线程，并将他们设置为脱离线程。
    for ( int i = 0; i < thread_number; ++i ) {
        printf( "create the %dth thread\n", i);
        if(pthread_create(m_threads + i, NULL, worker, this ) != 0) {
            delete [] m_threads;
            throw std::exception();
        }
        
        if( pthread_detach( m_threads[i] ) ) {
            delete [] m_threads;
            throw std::exception();
        }
    }
}

template< typename T >
threadpool< T >::~threadpool() {
    delete [] m_threads;
    m_stop = true;
}

template< typename T >
bool threadpool< T >::append( T* request )
{
    // 操作工作队列时一定要加锁，因为它被所有线程共享。
    m_queuelocker.lock();
    if ( m_workqueue.size() > m_max_requests ) {
        m_queuelocker.unlock();
        return false;
    }
    m_workqueue.push_back(request);
    m_queuelocker.unlock();
    m_queuestat.post();
    return true;
}

template< typename T >
void* threadpool< T >::worker( void* arg )
{
    threadpool* pool = ( threadpool* )arg;
    pool->run();
    return pool;
}

template< typename T >
void threadpool< T >::run() {

    while (!m_stop) {
        m_queuestat.wait();
        m_queuelocker.lock();
        if ( m_workqueue.empty() ) {
            m_queuelocker.unlock();
            continue;
        }
        T* request = m_workqueue.front();
        m_workqueue.pop_front();
        m_queuelocker.unlock();
        if ( !request ) {
            continue;
        }
        request->process();
    }

}

#endif
```

**b. 线程的同步机制有哪些？**

锁、信号量、条件变量。

**c. 线程池中的工作线程是一直等待吗？**

是的。线程池类中维护了一个请求队列，用来存储需要工作线程处理和响应的请求。线程池中还维护了互斥锁和信号量，来避免多工作线程对请求队列的读取冲突。没有获取请求队列互斥锁的工作线程会被阻塞，而获取了互斥锁的工作线程，在请求队列为空时，会直接释放锁。所以在请求队列中没有请求时，线程池中的线程会一直请求获取锁，而获取到锁的工作线程会因为没有请求而释放锁。当请求队列中有请求时，获取锁的线程会从请求队列中获取请求，而在这期间，其他工作队列是阻塞的。

```cpp
template<typename T>
void threadpool<T>::run()
{
    while(true)
    {
        m_queuestat.wait();
        m_queuelocker.lock();
        if(m_workqueue.empty())
        {
            m_queuelocker.unlock();
            continue;
        }
        T * request = m_workqueue.front();
        m_workqueue.pop_front();
        m_queuelocker.unlock();

        if(!request)
        {
            continue;
        }

        request->process();     // 执行任务
    }
}
```

**<u>*这里可以优化用条件变量来处理。*</u>**

**d. 你的线程池工作线程处理完一个任务后的状态是什么？**

工作线程一直在循环获取请求队列的互斥锁，获取了互斥锁后，如果有请求，则读取请求并处理，如果没有请求，则释放互斥锁并继续循环尝试获取锁。所以工作线程在处理完一个任务后会继续循环尝试获取锁，在获取锁之前会被阻塞。

```c++
template<typename T>
void threadpool<T>::run()
{
    while(true)
    {
        m_queuestat.wait();
        m_queuelocker.lock();
        if(m_workqueue.empty())
        {
            m_queuelocker.unlock();
            continue;
        }
        T * request = m_workqueue.front();
        m_workqueue.pop_front();
        m_queuelocker.unlock();

        if(!request)
        {
            continue;
        }

        request->process();     // 执行任务
    }
}
```

**e. 如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？**

我使用的是线程池，线程池中的工作线程在没有请求时一直阻塞，而在有请求时通过请求队列获取请求。所以不存在线程的创建和销毁这种开销很大的阶段，所以可以大大地提高服务器的性能，实现高并发的响应。

**f. 如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?**

会。可以设置一个超时时间，从工作线程处理请求开始计时，一旦线程处理完一个请求就重置计时器，一旦超时就让内核发送信号给线程，让线程放弃该请求的处理，转去处理请求队列中的其他请求。

**并发模型相关**

- 简单说一下服务器使用的并发模型？
- reactor、proactor、主从reactor模型的区别？
- 你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？

## HTTP报文解析相关

#### 1. 为什么要用状态机？

如果是直接面向报文解析过程解析的话，逻辑会很冗余，因为你要在每一个函数中处理所有可能出现的状态，状态一多就容易遗漏。而如果将整一个报文解析过程抽象成几个状态之间的逻辑关系，那就只要实现状态到状态之间的转换，不容易遗漏情况，同时逻辑有很清晰。

#### 2. 状态机的转移图

主状态机

从状态机

#### 3. HTTP 报文解析流程

主函数 `process`

a. 首先 `process_read` 读取 HTTP 报文，并解析，返回解析结果

b. 如果解析结果为数据读取不完全，则将该连接的 `sockfd` 重新添加到 `epoll` 监听的事件中，等待下一次事件。

c. **==根据报文解析的结果，`process_write` 生成响应报文，将其写入写缓冲区==**。

d. **==如果响应报文生成的过程中出现了问题，那么 `process` 直接关闭连接==**。

e. 最后将连接的 `sockfd` 的写事件添加到 `epoll` 的监听事件中，`epoll` 在监听到事件后，会调用 `write` 函数，向客户端发送响应报文。



读取报文并解析 `process_read`：HTTP_STATUS 的转换，通过 `parse_line` 每次获取一行

`CHECK_STATE_REQUESTLINE` - `CHECK_STATE_HEADER` - `CHECK_STATE_CONTENT`

`CHECK_STATE_REQUESTLINE` :

`parse_request_line` 解析请求行，解析成功则转到  `CHECK_STATE_HEADER`

 `CHECK_STATE_HEADER`：

`parse_headers` 解析请求头，如果存在 `Content-Length` 字段，则需要转到 `CHECK_STATE_CONTENT`

`CHECK_STATE_CONTENT`：

`parse_content` 仅获取请求数据，根据 `Content-Length` 字段的值判断获取的长度



- https协议为什么安全？
- https的ssl连接过程
- GET和POST的区别

**定时器相关**

- 为什么要用定时器？
- 说一下定时器的工作原理
- 双向链表啊，删除和添加的时间复杂度说一下？还可以优化吗？
- 最小堆优化？说一下时间复杂度和工作原理

**日志相关**

- 说下你的日志系统的运行机制？
- 为什么要异步？和同步的区别是什么？
- 现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）

**压测相关**

- 服务器并发量测试过吗？怎么测试的？
- webbench是什么？介绍一下原理
- 测试的时候有没有遇到问题？

**综合能力**

- 你的项目解决了哪些其他同类项目没有解决的问题？
- 说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？